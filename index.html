<!DOCTYPE html>
<!-- DO NOT EDIT THIS FILE, IT'S AUTOMATICALLY GENERATED! -->
<html>
<title>The Chalmers Online Functional Programming Seminar Series</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="http://www.w3schools.com/w3css/4/w3.css">
<style>
hr {
border-width: 2px;
margin-top: 6px;
margin-bottom: 6px;
}
table, td, th {
border: 1px solid #ddd;
}
table {
border-collapse: collapse;
}
th, td {
padding: 15px;
}
html, body {
font-family: "Actor", sans-serif; font-size: 18px
}
</style>
<body>

<!-- TOP BAR -->
<div class="w3-top w3-black w3-card-2 w3-padding-large w3-center">CHALMERS ONLINE FUNCTIONAL PROGRAMMING SEMINAR SERIES</div>

<div id="content" class="w3-content w3-padding-16" style="max-width:1200px;margin-top:46px">
<!-- BEGIN page content -->

<p class="w3-container w3-padding-small">
The Chalmers Online Functional Programming Seminar Series is organized by the Chalmers Functional Programming Group, as a way to exploit the fact that so many of us in the FP community are already meeting and working online these days. Our aim is to bring the people in the FP community closer together, to educate and inspire, and to foster collaboration.
<br> <br>
The seminars will take place every Monday (at 6am PDT / 10am EDT / 16:00 CET) and are organized through Zoom.
<br> <br>
<strong><a href="https://calendar.google.com/calendar?cid=cmgydWQ1c3JzNzRzdTU3NHBlcnZ0aHJmYjBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ">Google Calendar Link</a></strong>
<br> <br>
<strong><a href="http://chalmers.zoom.us/">Zoom Link for all seminars</a></strong>
</span>
</p>

<p class='w3-center'><strong>upcoming talks</strong></p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>May 11</strong><br>
<span style='font-size:larger'>""</span><br>
by <a href="https://www.microsoft.com/en-us/research/people/simonpj/">Simon Peyton Jones</a> (Microsoft Research)<br>
<hr>
<br>
<strong>audience</strong>: 
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday May 11, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>May 18</strong><br>
<span style='font-size:larger'>""</span><br>
by <a href="https://www.cis.upenn.edu/~bcpierce/">Benjamin Pierce</a> (UPenn)<br>
<hr>
QuickCheck-style property-based testing relies on random generators that produce well-distributed test data.
When the properties under test involve sparse preconditions, test generators must be written so as to produce
constrained test data satisfying these preconditions. But what should such generators do when choices made
early on render later constraints unsatisfiable? How can generation effort be reused, both when failure is a
possibility and, more generally, when parts of a complex test are relatively expensive to generate? The natural
answer to all these questions is to use backtracking.
<br> <br>
We propose a new generator abstraction, extending QuickCheck generators with local backtracking by
enriching the key Gen monad to support backtracking under the hood; and we show, in this setting, how local
backtracking can significantly improve end-to-end bug-finding performance in two case studies. We show, first,
that adding a small amount of backtracking improves the performance of a generator for well-typed System
F terms by 1.6× on average. When generating System F terms, backtracking allows us to avoid completely
discarding generation effort in the presence of uninhabitable types, which we find allows us to produce larger,
more effective test cases—requiring 2.1× fewer tests, on average, to discover a bug. Second, we show that
adding backtracking to an existing, highly tuned generator for random machine states in a testing framework
for dynamic information flow control monitors allows us to amortize an expensive step in test-case generation,
improving bug-finding performance by 3.9× with only a tiny change in the generator.
<br>
<strong>audience</strong>: 
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday May 18, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>May 25</strong><br>
<span style='font-size:larger'>""</span><br>
by <a href="https://cseweb.ucsd.edu/~npolikarpova/">Nadia Polikarpova</a> (UCSD)<br>
<hr>
<br>
<strong>audience</strong>: 
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday May 25, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>June 1</strong><br>
<span style='font-size:larger'>"Using Formal Methods to Eliminate Exploitable Bugs"</span><br>
by <a href="http://www.cs.tufts.edu/~kfisher/Kathleen_Fisher/Home.html">Kathleen Fisher</a> (Tufts University, Former Program Manager of DARPA’s HACMS Program)<br>
<hr>
For decades, formal methods have offered the promise of software that doesn’t have exploitable bugs.  Until recently, however, it hasn’t been possible to verify software of sufficient complexity to be useful. Recently, that situation has changed.  SeL4 is an open-source operating system microkernel efficient enough to be used in a wide range of practical applications. It has been proven to be fully functionally correct, ensuring the absence of buffer overflows, null pointer exceptions, use-after-free errors, etc., and to enforce integrity and confidentiality properties.  The CompCert Verifying C Compiler maps source C programs to provably equivalent assembly language, ensuring the absence of exploitable bugs in the compiler.    A number of factors have enabled this revolution in the formal methods community, including increased processor speed, better infrastructure like the Isabelle/HOL and Coq theorem provers, specialized logics for reasoning about low-level code, increasing levels of automation afforded by tactic languages and SAT/SMT solvers, and the decision to move away from trying to verify existing artifacts and instead focus on co-developing the code and the correctness proof.   In this talk I will explore the promise and limitations of current formal methods techniques for producing useful software that provably does not contain exploitable bugs.  I will discuss these issues in the context of DARPA’s HACMS program, which had as its goal the creation of high-assurance software for vehicles, including quad-copters, helicopters, and automobiles.  
<br>
<strong>audience</strong>: 
<hr>
<strong>#research #application</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday June 1, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>June 8</strong><br>
<span style='font-size:larger'>""</span><br>
by <a href="http://homepages.inf.ed.ac.uk/wadler/">Phil Wadler</a> (University of Edinburgh)<br>
<hr>
<br>
<strong>audience</strong>: 
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday June 8, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>June 15</strong><br>
<span style='font-size:larger'>"Higher-order concolic testing"</span><br>
by <a href="https://users.cs.northwestern.edu/~robby/">Robby Findler</a> (Northwestern University)<br>
<hr>
I will explain what higher-order concolic testing is (using concolic testing on programs that accept functions as inputs). I will try to be very example-driven to explain what we've figured out about the problem so far.
<br>
<strong>audience</strong>: People need to be used to reading short fragments of code with lambdas in them
<hr>
<strong>#research #work-in-progress</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday June 15, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>June 22</strong><br>
<span style='font-size:larger'>"Strongly Typed System F in GHC"</span><br>
by <a href="https://www.cis.upenn.edu/~sweirich/">Stephanie Weirich</a> (UPenn)<br>
<hr>
There are many examples that demonstrate how to create a strongly typed abstract syntax in Haskell for a language with a simple type system. But there are many fewer examples that allow the embedded language to be polymorphic. I will work through what it takes to do so, touching on variable binding representations, and exploring the limits of dependently-typed programming in GHC.
<br>
<strong>audience</strong>: Haskellers that are familiar with GADTs and/or strongly typed abstract syntax.
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday June 22, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>
<div class='w3-container w3-padding-small w3-border-blue w3-border'>
<strong>June 29</strong><br>
<span style='font-size:larger'>""</span><br>
by <a href="https://www.cs.ox.ac.uk/people/jeremy.gibbons/">Jeremy Gibbons</a> (Oxford University)<br>
<hr>
<br>
<strong>audience</strong>: 
<hr>
<strong>#research</strong><span style='float:right'><a href="http://chalmers.zoom.us/">Zoom link for Monday June 29, 6am PDT / 10am EDT / 16:00 CET</a></span>
</div>
<p> </p>

<!-- END page content -->
</div>

</body>
</html>

