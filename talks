
#zoom http://chalmers.zoom.us/

--------------------------------------------------------------------------------

#date 2020-05-11
#speaker <a href="https://www.microsoft.com/en-us/research/people/simonpj/">Simon Peyton Jones</a> (Microsoft Research)
#title 
#abstract
#audience
#tags #research

--------------------------------------------------------------------------------

#date 2020-05-18
#speaker <a href="https://www.cis.upenn.edu/~bcpierce/">Benjamin Pierce</a> (UPenn)
#title
#abstract
QuickCheck-style property-based testing relies on random generators that produce well-distributed test data.
When the properties under test involve sparse preconditions, test generators must be written so as to produce
constrained test data satisfying these preconditions. But what should such generators do when choices made
early on render later constraints unsatisfiable? How can generation effort be reused, both when failure is a
possibility and, more generally, when parts of a complex test are relatively expensive to generate? The natural
answer to all these questions is to use backtracking.
<br> <br>
We propose a new generator abstraction, extending QuickCheck generators with local backtracking by
enriching the key Gen monad to support backtracking under the hood; and we show, in this setting, how local
backtracking can significantly improve end-to-end bug-finding performance in two case studies. We show, first,
that adding a small amount of backtracking improves the performance of a generator for well-typed System
F terms by 1.6× on average. When generating System F terms, backtracking allows us to avoid completely
discarding generation effort in the presence of uninhabitable types, which we find allows us to produce larger,
more effective test cases—requiring 2.1× fewer tests, on average, to discover a bug. Second, we show that
adding backtracking to an existing, highly tuned generator for random machine states in a testing framework
for dynamic information flow control monitors allows us to amortize an expensive step in test-case generation,
improving bug-finding performance by 3.9× with only a tiny change in the generator.
#audience
#tags #research

--------------------------------------------------------------------------------

#date 2020-05-25
#speaker <a href="https://cseweb.ucsd.edu/~npolikarpova/">Nadia Polikarpova</a> (UCSD)
#title
#abstract
#audience
#tags #research

--------------------------------------------------------------------------------

#date 2020-06-01
#speaker <a href="http://www.cs.tufts.edu/~kfisher/Kathleen_Fisher/Home.html">Kathleen Fisher</a> (Tufts University, Former Program Manager of DARPA’s HACMS Program)
#title Using Formal Methods to Eliminate Exploitable Bugs
#abstract
For decades, formal methods have offered the promise of software that doesn’t have exploitable bugs.  Until recently, however, it hasn’t been possible to verify software of sufficient complexity to be useful. Recently, that situation has changed.  SeL4 is an open-source operating system microkernel efficient enough to be used in a wide range of practical applications. It has been proven to be fully functionally correct, ensuring the absence of buffer overflows, null pointer exceptions, use-after-free errors, etc., and to enforce integrity and confidentiality properties.  The CompCert Verifying C Compiler maps source C programs to provably equivalent assembly language, ensuring the absence of exploitable bugs in the compiler.    A number of factors have enabled this revolution in the formal methods community, including increased processor speed, better infrastructure like the Isabelle/HOL and Coq theorem provers, specialized logics for reasoning about low-level code, increasing levels of automation afforded by tactic languages and SAT/SMT solvers, and the decision to move away from trying to verify existing artifacts and instead focus on co-developing the code and the correctness proof.   In this talk I will explore the promise and limitations of current formal methods techniques for producing useful software that provably does not contain exploitable bugs.  I will discuss these issues in the context of DARPA’s HACMS program, which had as its goal the creation of high-assurance software for vehicles, including quad-copters, helicopters, and automobiles.  
#audience
#tags #research #application

--------------------------------------------------------------------------------

#date 2020-06-08
#speaker <a href="http://homepages.inf.ed.ac.uk/wadler/">Phil Wadler</a> (University of Edinburgh)
#title
#abstract
#audience
#tags #research

--------------------------------------------------------------------------------

#date 2020-06-15
#speaker <a href="https://users.cs.northwestern.edu/~robby/">Robby Findler</a> (Northwestern University)
#title Higher-order concolic testing
#abstract
I will explain what higher-order concolic testing is (using concolic testing on programs that accept functions as inputs). I will try to be very example-driven to explain what we've figured out about the problem so far.
#audience People need to be used to reading short fragments of code with lambdas in them
#tags #research #work-in-progress

--------------------------------------------------------------------------------

#date 2020-06-22
#speaker <a href="https://www.cis.upenn.edu/~sweirich/">Stephanie Weirich</a> (UPenn)
#title Strongly Typed System F in GHC
#abstract
There are many examples that demonstrate how to create a strongly typed abstract syntax in Haskell for a language with a simple type system. But there are many fewer examples that allow the embedded language to be polymorphic. I will work through what it takes to do so, touching on variable binding representations, and exploring the limits of dependently-typed programming in GHC.
#audience Haskellers that are familiar with GADTs and/or strongly typed abstract syntax.
#tags #research

--------------------------------------------------------------------------------

#date 2020-06-29
#speaker <a href="https://www.cs.ox.ac.uk/people/jeremy.gibbons/">Jeremy Gibbons</a> (Oxford University)
#title
#abstract
#audience
#tags #research

--------------------------------------------------------------------------------



